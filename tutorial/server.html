<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Serving an API - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">servant</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../blog.html">Blog</a>
                <a href="../tutorial">Tutorial</a>
                <a href="../tips.html">Tips and tricks</a>
                <a href="../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Serving an API</h1>

            <div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#a-first-example">A first example</a></li>
<li><a href="#more-endpoints">More endpoints</a></li>
<li><a href="#from-combinators-to-handler-arguments">From combinators to handler arguments</a></li>
<li><a href="#the-fromtexttotext-classes">The <code>FromText</code>/<code>ToText</code> classes</a></li>
<li><a href="#using-content-types-with-your-data-types">Using content-types with your data types</a><ul>
<li><a href="#the-truth-behind-json">The truth behind <code>JSON</code></a></li>
<li><a href="#case-studies-servant-blaze-and-servant-lucid">Case-studies: <em>servant-blaze</em> and <em>servant-lucid</em></a></li>
</ul></li>
<li><a href="#the-eithert-servanterr-io-monad">The <code>EitherT ServantErr IO</code> monad</a><ul>
<li><a href="#performing-io">Performing IO</a></li>
<li><a href="#failing-through-servanterr">Failing, through <code>ServantErr</code></a></li>
</ul></li>
<li><a href="#serving-static-files">Serving static files</a></li>
<li><a href="#using-another-monad-for-your-handlers">Using another monad for your handlers</a><ul>
<li><a href="#natural-transformations">Natural transformations</a></li>
<li><a href="#enter-enter">Enter <code>enter</code></a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></div>
<p>Enough chit-chat about type-level combinators and representing an API as a type. Can we have a webservice already?</p>
<p>If you want to follow along with the code and run the examples while you read this guide:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/haskell-servant/servant.git
<span class="kw">cd</span> servant
<span class="kw">cabal</span> sandbox init
<span class="kw">cabal</span> sandbox add-source servant/ servant-client/ servant-server/ servant-jquery/ servant-docs/ servant-examples/
<span class="kw">cd</span> servant-examples
<span class="kw">cabal</span> install --only-dependencies
<span class="kw">cabal</span> configure <span class="kw">&amp;&amp;</span> <span class="kw">cabal</span> build</code></pre>
<p>This will produce a <code>tutorial</code> executable in the <code>dist/build/tutorial</code> directory that just runs the example corresponding to the number specified as a command line argument:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">dist/build/tutorial/tutorial</span>
<span class="kw">Usage</span>:   tutorial N
        <span class="kw">where</span> N is the number of the example you want to run.</code></pre>
<section id="a-first-example" class="level2">
<h2>A first example</h2>
<p>Equipped with some basic knowledge about the way we represent API, let’s now write our first webservice.</p>
<p>We will write a server that will serve the following API.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span></code></pre>
<p>Here’s what we would like to see when making a GET request to <code>/users</code>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">[ {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Isaac Newton&quot;</span>, <span class="st">&quot;age&quot;</span>: <span class="dv">372</span>, <span class="st">&quot;email&quot;</span>: <span class="st">&quot;isaac@newton.co.uk&quot;</span>, <span class="st">&quot;registration_date&quot;</span>: <span class="st">&quot;1683-03-01&quot;</span>}
, {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Albert Einstein&quot;</span>, <span class="st">&quot;age&quot;</span>: <span class="dv">136</span>, <span class="st">&quot;email&quot;</span>: <span class="st">&quot;ae@mc2.org&quot;</span>, <span class="st">&quot;registration_date&quot;</span>: <span class="st">&quot;1905-12-01&quot;</span>}
]</code></pre>
<p>Some imports and <code>LANGUAGE</code> pragmas:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Time.Calendar</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span>
<span class="kw">import </span><span class="dt">Servant</span></code></pre>
<p>Now let’s define our <code>User</code> data type and write some instances for it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
  {<span class="ot"> name ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> email ::</span> <span class="dt">String</span>
  ,<span class="ot"> registration_date ::</span> <span class="dt">Day</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="co">-- orphan ToJSON instance for Day. necessary to derive one for User</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Day</span> <span class="kw">where</span>
  <span class="co">-- display a day in YYYY-mm-dd format</span>
  toJSON d <span class="fu">=</span> toJSON (showGregorian d)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span></code></pre>
<p>Nothing funny going on here. But we now can define our list of two users.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">users ::</span> [<span class="dt">User</span>]
users <span class="fu">=</span>
  [ <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span>    <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span>  <span class="dv">3</span> <span class="dv">1</span>)
  , <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span>         (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)
  ]</code></pre>
<p>Let’s also write our API type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span></code></pre>
<p>We can now take care of writing the actual webservice that will handle requests to such an API. This one will be very simple, being reduced to just a single endpoint. The type of the web application is determined by the API type, through a <em>type family</em> named <code>Server</code>. (Type families are just functions that take types as input and return types.) The <code>Server</code> type family will compute the right type that a bunch of request handlers should have just from the corresponding API type.</p>
<p>The first thing to know about the <code>Server</code> type family is that behind the scenes it will drive the routing, letting you focus only on the business logic. The second thing to know is that for each endpoint, your handlers will by default run in the <code>EitherT ServantErr IO</code> monad. This is overridable very easily, as explained near the end of this guide. Third thing, the type of the value returned in that monad must be the same as the second argument of the HTTP method combinator used for the corresponding endpoint. In our case, it means we must provide a handler of type <code>EitherT ServantErr IO [User]</code>. Well, we have a monad, let’s just <code>return</code> our list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">UserAPI</span>
server <span class="fu">=</span> return users</code></pre>
<p>That’s it. Now we can turn <code>server</code> into an actual webserver using <a href="http://hackage.haskell.org/package/wai">wai</a> and <a href="http://hackage.haskell.org/package/warp">warp</a>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userAPI ::</span> <span class="dt">Proxy</span> <span class="dt">UserAPI</span>
userAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="co">-- 'serve' comes from servant and hands you a WAI Application,</span>
<span class="co">-- which you can think of as an &quot;abstract&quot; web application,</span>
<span class="co">-- not yet a webserver.</span>
<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve userAPI server</code></pre>
<p>The <code>userAPI</code> bit is, alas, boilerplate (we need it to guide type inference). But that’s about as much boilerplate as you get.</p>
<p>And we’re done! Let’s run our webservice on the port 8081.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">8081</span> app</code></pre>
<p>You can put this all into a file or just grab <a href="http://github.com/haskell-servant/servant">servant’s repo</a> and look at the <em>servant-examples</em> directory. The code we have just explored is in <em>tutorial/T1.hs</em>, runnable with <code>dist/build/tutorial/tutorial 2</code>.</p>
<p>If you run it, you can go to <code>http://localhost:8081/users</code> in your browser or query it with curl and you see:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/users
[{<span class="st">&quot;email&quot;</span>:<span class="st">&quot;isaac@newton.co.uk&quot;</span>,<span class="st">&quot;registration_date&quot;</span>:<span class="st">&quot;1683-03-01&quot;</span>,<span class="st">&quot;age&quot;</span>:<span class="kw">372</span>,<span class="st">&quot;name&quot;</span>:<span class="st">&quot;Isaac Newton&quot;</span>},{<span class="st">&quot;email&quot;</span>:<span class="st">&quot;ae@mc2.org&quot;</span>,<span class="st">&quot;registration_date&quot;</span>:<span class="st">&quot;1905-12-01&quot;</span>,<span class="st">&quot;age&quot;</span>:<span class="kw">136</span>,<span class="st">&quot;name&quot;</span>:<span class="st">&quot;Albert Einstein&quot;</span>}]</code></pre>
</section>
<section id="more-endpoints" class="level2">
<h2>More endpoints</h2>
<p>What if we want more than one endpoint? Let’s add <code>/albert</code> and <code>/isaac</code> to view the corresponding users encoded in JSON.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span>
          <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;albert&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User</span>
          <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;isaac&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User</span></code></pre>
<p>And let’s adapt our code a bit.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isaac ::</span> <span class="dt">User</span>
isaac <span class="fu">=</span> <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span> <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span> <span class="dv">3</span> <span class="dv">1</span>)

<span class="ot">albert ::</span> <span class="dt">User</span>
albert <span class="fu">=</span> <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span> (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)

<span class="ot">users ::</span> [<span class="dt">User</span>]
users <span class="fu">=</span> [isaac, albert]</code></pre>
<p>Now, just like we separate the various endpoints in <code>UserAPI</code> with <code>:&lt;|&gt;</code>, we are going to separate the handlers with <code>:&lt;|&gt;</code> too! They must be provided in the same order as the one they appear in in the API type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">UserAPI</span>
server <span class="fu">=</span> return users
    <span class="fu">:&lt;|&gt;</span> return albert
    <span class="fu">:&lt;|&gt;</span> return isaac</code></pre>
<p>And that’s it! You can run this example with <code>dist/build/tutorial/tutorial 2</code> and check out the data available at <code>/users</code>, <code>/albert</code> and <code>/isaac</code>.</p>
</section>
<section id="from-combinators-to-handler-arguments" class="level2">
<h2>From combinators to handler arguments</h2>
<p>Fine, we can write trivial webservices easily, but none of the two above use any “fancy” combinator from servant. Let’s address this and use <code>QueryParam</code>, <code>Capture</code> and <code>ReqBody</code> right away. You’ll see how each occurence of these combinators in an endpoint makes the corresponding handler receive an argument of the appropriate type automatically. You don’t have to worry about manually looking up URL captures or query string parameters, or decoding/encoding data from/to JSON. Never.</p>
<p>First off, again, some pragmas and imports.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Either</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant</span></code></pre>
<p>We are going to use the following data types and functions to implement a server for <code>API</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;position&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Position</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] HelloMessage</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;marketing&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] ClientInfo :&gt; Post '</span>[<span class="dt">JSON</span>] <span class="dt">Email</span>

<span class="kw">data</span> <span class="dt">Position</span> <span class="fu">=</span> <span class="dt">Position</span>
  {<span class="ot"> x ::</span> <span class="dt">Int</span>
  ,<span class="ot"> y ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Position</span>

<span class="kw">newtype</span> <span class="dt">HelloMessage</span> <span class="fu">=</span> <span class="dt">HelloMessage</span> {<span class="ot"> msg ::</span> <span class="dt">String</span> }
  <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">HelloMessage</span>

<span class="kw">data</span> <span class="dt">ClientInfo</span> <span class="fu">=</span> <span class="dt">ClientInfo</span>
  {<span class="ot"> name ::</span> <span class="dt">String</span>
  ,<span class="ot"> email ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> interested_in ::</span> [<span class="dt">String</span>]
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">ClientInfo</span>

<span class="kw">data</span> <span class="dt">Email</span> <span class="fu">=</span> <span class="dt">Email</span>
  {<span class="ot"> from ::</span> <span class="dt">String</span>
  ,<span class="ot"> to ::</span> <span class="dt">String</span>
  ,<span class="ot"> subject ::</span> <span class="dt">String</span>
  ,<span class="ot"> body ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Email</span>

<span class="ot">emailForClient ::</span> <span class="dt">ClientInfo</span> <span class="ot">-&gt;</span> <span class="dt">Email</span>
emailForClient c <span class="fu">=</span> <span class="dt">Email</span> from' to' subject' body'

  <span class="kw">where</span> from'    <span class="fu">=</span> <span class="st">&quot;great@company.com&quot;</span>
        to'      <span class="fu">=</span> email c
        subject' <span class="fu">=</span> <span class="st">&quot;Hey &quot;</span> <span class="fu">++</span> name c <span class="fu">++</span> <span class="st">&quot;, we miss you!&quot;</span>
        body'    <span class="fu">=</span> <span class="st">&quot;Hi &quot;</span> <span class="fu">++</span> name c <span class="fu">++</span> <span class="st">&quot;,\n\n&quot;</span>
                <span class="fu">++</span> <span class="st">&quot;Since you've recently turned &quot;</span> <span class="fu">++</span> show (age c)
                <span class="fu">++</span> <span class="st">&quot;, have you checked out our latest &quot;</span>
                <span class="fu">++</span> intercalate <span class="st">&quot;, &quot;</span> (interested_in c)
                <span class="fu">++</span> <span class="st">&quot; products? Give us a visit!&quot;</span></code></pre>
<p>We can implement handlers for the three endpoints:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span>
server <span class="fu">=</span> position
    <span class="fu">:&lt;|&gt;</span> hello
    <span class="fu">:&lt;|&gt;</span> marketing

  <span class="kw">where</span><span class="ot"> position ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Position</span>
        position x y <span class="fu">=</span> return (<span class="dt">Position</span> x y)

<span class="ot">        hello ::</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">HelloMessage</span>
        hello mname <span class="fu">=</span> return <span class="fu">.</span> <span class="dt">HelloMessage</span> <span class="fu">$</span> <span class="kw">case</span> mname <span class="kw">of</span>
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Hello, anonymous coward&quot;</span>
          <span class="dt">Just</span> n  <span class="ot">-&gt;</span> <span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> n

<span class="ot">        marketing ::</span> <span class="dt">ClientInfo</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Email</span>
        marketing clientinfo <span class="fu">=</span> return (emailForClient clientinfo)</code></pre>
<p>Did you see that? The types for your handlers changed to be just what we needed! In particular: - a <code>Capture &quot;something&quot; a</code> becomes an argument of type <code>a</code> (for <code>position</code>); - a <code>QueryParam &quot;something&quot; a</code> becomes an argument of type <code>Maybe a</code> (because an endpoint can technically be accessed without specifying any query string parameter, we decided to “force” handlers to be aware that the parameter might not always be there); - a <code>ReqBody contentTypeList a</code> becomes an argument of type <code>a</code>;</p>
<p>And that’s it. You can see this example in action by running <code>dist/build/tutorial/tutorial 3</code>.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/position/1/2
<span class="dt">{&quot;x&quot;:1,&quot;y&quot;:2}</span>
$ <span class="kw">curl</span> http://localhost:8081/hello
{<span class="st">&quot;msg&quot;</span>:<span class="st">&quot;Hello, anonymous coward&quot;</span>}
$ <span class="kw">curl</span> http://localhost:8081/hello?name=Alp
{<span class="st">&quot;msg&quot;</span>:<span class="st">&quot;Hello, Alp&quot;</span>}
$ <span class="kw">curl</span> -X POST -d <span class="st">'{&quot;name&quot;:&quot;Alp Mestanogullari&quot;, &quot;email&quot; : &quot;alp@foo.com&quot;, &quot;age&quot;: 25, &quot;interested_in&quot;: [&quot;haskell&quot;, &quot;mathematics&quot;]}'</span> -H <span class="st">'Accept: application/json'</span> -H <span class="st">'Content-type: application/json'</span> http://localhost:8081/marketing
{<span class="st">&quot;subject&quot;</span>:<span class="st">&quot;Hey Alp Mestanogullari, we miss you!&quot;</span>,<span class="st">&quot;body&quot;</span>:<span class="st">&quot;Hi Alp Mestanogullari,\n\nSince you've recently turned 25, have you checked out our latest haskell, mathematics products? Give us a visit!&quot;</span>,<span class="st">&quot;to&quot;</span>:<span class="st">&quot;alp@foo.com&quot;</span>,<span class="st">&quot;from&quot;</span>:<span class="st">&quot;great@company.com&quot;</span>}</code></pre>
<p>For reference, here’s a list of some combinators from <em>servant</em> and for those that get turned into arguments to the handlers, the type of the argument.</p>
<blockquote>
<ul>
<li><code>Delete</code>, <code>Get</code>, <code>Patch</code>, <code>Post</code>, <code>Put</code>: these do not become arguments. They provide the return type of handlers, which usually is <code>EitherT ServantErr IO &lt;something&gt;</code>.</li>
<li><code>Capture &quot;something&quot; a</code> becomes an argument of type <code>a</code>.</li>
<li><code>QueryParam &quot;something&quot; a</code>, <code>MatrixParam &quot;something&quot; a</code>, <code>Header &quot;something&quot; a</code> both become an argument of type <code>Maybe a</code>, because there might be no value at all specified by the client for these.</li>
<li><code>QueryFlag &quot;something&quot;</code> and <code>MatrixFlag &quot;something&quot;</code> get turned into arguments of type <code>Bool</code>.</li>
<li><code>QueryParams &quot;something&quot; a</code> and <code>MatrixParams &quot;something&quot; a</code> get turned into arguments of type <code>[a]</code>.</li>
<li><code>ReqBody contentTypes a</code> gets turned into an argument of type <code>a</code>.</li>
</ul>
</blockquote>
</section>
<section id="the-fromtexttotext-classes" class="level2">
<h2>The <code>FromText</code>/<code>ToText</code> classes</h2>
<p>Wait… How does <em>servant</em> know how to decode the <code>Int</code>s from the URL? Or how to decode a <code>ClientInfo</code> value from the request body? This is what this and the following two sections address.</p>
<p><code>Capture</code>s and <code>QueryParam</code>s are represented by some textual value in URLs. <code>Header</code>s are similarly represented by a pair of a header name and a corresponding (textual) value in the request’s “metadata”. This is why we decided to provide a pair of typeclasses, <code>FromText</code> and <code>ToText</code> which just let you say that you can respectively <em>extract</em> or <em>encode</em> values of some type <em>from</em>/<em>to</em> text. Here are the definitions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FromText</span> a <span class="kw">where</span>
<span class="ot">  fromText ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a

<span class="kw">class</span> <span class="dt">ToText</span> a <span class="kw">where</span>
<span class="ot">  toText ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre>
<p>And as long as the type that a <code>Capture</code>/<code>QueryParam</code>/<code>Header</code>/etc will be decoded to provides a <code>FromText</code> instance, it will Just Work. <em>servant</em> provides a decent number of instances, but here are a some examples of defining your own.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- A typical enumeration</span>
<span class="kw">data</span> <span class="dt">Direction</span>
  <span class="fu">=</span> <span class="dt">Up</span>
  <span class="fu">|</span> <span class="dt">Down</span>
  <span class="fu">|</span> <span class="dt">Left</span>
  <span class="fu">|</span> <span class="dt">Right</span>

<span class="kw">instance</span> <span class="dt">FromText</span> <span class="dt">Direction</span> <span class="kw">where</span>
  <span class="co">-- requires {-# LANGUAGE OverloadedStrings #-}</span>
  fromText <span class="st">&quot;up&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Up</span>
  fromText <span class="st">&quot;down&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Down</span>
  fromText <span class="st">&quot;left&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Left</span>
  fromText <span class="st">&quot;right&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Right</span>
  fromText       _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">ToText</span> <span class="dt">Direction</span> <span class="kw">where</span>
  toText <span class="dt">Up</span>    <span class="fu">=</span> <span class="st">&quot;up&quot;</span>
  toText <span class="dt">Down</span>  <span class="fu">=</span> <span class="st">&quot;down&quot;</span>
  toText <span class="dt">Left</span>  <span class="fu">=</span> <span class="st">&quot;left&quot;</span>
  toText <span class="dt">Right</span> <span class="fu">=</span> <span class="st">&quot;right&quot;</span>

<span class="kw">newtype</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">UserId</span> <span class="dt">Int64</span>
  <span class="kw">deriving</span> (<span class="dt">FromText</span>, <span class="dt">ToText</span>)
  <span class="co">-- requires GeneralizedNewtypeDeriving</span>

<span class="co">-- or writing the instances by hand:</span>
<span class="kw">instance</span> <span class="dt">FromText</span> <span class="dt">UserId</span> <span class="kw">where</span>
  fromText <span class="fu">=</span> fmap <span class="dt">UserId</span> fromText

<span class="kw">instance</span> <span class="dt">ToText</span> <span class="dt">UserId</span> <span class="kw">where</span>
  toText (<span class="dt">UserId</span> i) <span class="fu">=</span> toText i</code></pre>
<p>There’s not much else to say about these classes. You will need instances for them when using <code>Capture</code>, <code>QueryParam</code>, <code>QueryParams</code>, <code>MatrixParam</code>, <code>MatrixParams</code> and <code>Header</code> with your types. You will need <code>FromText</code> instances for server-side request handlers and <code>ToText</code> instances only when using <em>servant-client</em>, described in the section about deriving haskell functions to query an API.</p>
</section>
<section id="using-content-types-with-your-data-types" class="level2">
<h2>Using content-types with your data types</h2>
<p>The same principle was operating when decoding request bodies from JSON, and responses <em>into</em> JSON. (JSON is just the running example - you can do this with any content-type.)</p>
<p>This section introduces a couple of typeclasses provided by <em>servant</em> that make all of this work.</p>
<section id="the-truth-behind-json" class="level3">
<h3>The truth behind <code>JSON</code></h3>
<p>What exactly is <code>JSON</code>? Like the 3 other content types provided out of the box by <em>servant</em>, it’s a really dumb data type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">JSON</span>
<span class="kw">data</span> <span class="dt">PlainText</span>
<span class="kw">data</span> <span class="dt">FormUrlEncoded</span>
<span class="kw">data</span> <span class="dt">OctetStream</span></code></pre>
<p>Obviously, this is not all there is to <code>JSON</code>, otherwise it would be quite pointless. Like most of the data types in <em>servant</em>, <code>JSON</code> is mostly there as a special <em>symbol</em> that’s associated with encoding (resp. decoding) to (resp. from) the <em>JSON</em> format. The way this association is performed can be decomposed into two steps.</p>
<p>The first step is to provide a proper <a href="https://hackage.haskell.org/package/http-media-0.6.2/docs/Network-HTTP-Media.html"><code>MediaType</code></a> representation for <code>JSON</code>, or for your own content types. If you look at the haddocks from this link, you can see that we just have to specify <code>application/json</code> using the appropriate functions. In our case, we can just use <code>(//) :: ByteString -&gt; ByteString -&gt; MediaType</code>. The precise way to specify the <code>MediaType</code> is to write an instance for the <code>Accept</code> class:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- for reference:</span>
<span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="kw">where</span>
<span class="ot">    contentType   ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> <span class="dt">MediaType</span>

<span class="kw">instance</span> <span class="dt">Accept</span> <span class="dt">JSON</span> <span class="kw">where</span>
    contentType _ <span class="fu">=</span> <span class="st">&quot;application&quot;</span> <span class="fu">//</span> <span class="st">&quot;json&quot;</span></code></pre>
<p>The second step is centered around the <code>MimeRender</code> and <code>MimeUnrender</code> classes. These classes just let you specify a way to respectively encode and decode values respectively into or from your content-type’s representation.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> ctype a <span class="kw">where</span>
<span class="ot">    mimeRender  ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
    <span class="co">-- alternatively readable as:</span>
<span class="ot">    mimeRender  ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>)</code></pre>
<p>Given a content-type and some user type, <code>MimeRender</code> provides a function that encodes values of type <code>a</code> to lazy <code>ByteString</code>s.</p>
<p>In the case of <code>JSON</code>, this is easily dealt with! For any type <code>a</code> with a <code>ToJSON</code> instance, we can render values of that type to JSON using <code>Data.Aeson.encode</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">JSON</span> a <span class="kw">where</span>
  mimeRender _ <span class="fu">=</span> encode</code></pre>
<p>And now the <code>MimeUnrender</code> class, which lets us extract values from lazy <code>ByteString</code>s, alternatively failing with an error string.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="ot">=&gt;</span> <span class="dt">MimeUnrender</span> ctype a <span class="kw">where</span>
<span class="ot">    mimeUnrender ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
    <span class="co">-- alternatively:</span>
<span class="ot">    mimeUnrender ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> (<span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a)</code></pre>
<p>We don’t have much work to do there either, <code>Data.Aeson.eitherDecode</code> is precisely what we need. However, it only allows arrays and objects as toplevel JSON values and this has proven to get in our way more than help us so we wrote our own little function around <em>aeson</em> and <em>attoparsec</em> that allows any type of JSON value at the toplevel of a “JSON document”. Here’s the definition in case you are curious.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eitherDecodeLenient ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
eitherDecodeLenient input <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">    v ::</span> <span class="dt">Value</span> <span class="ot">&lt;-</span> parseOnly (Data.Aeson.Parser.value <span class="fu">&lt;*</span> endOfInput) (cs input)
    parseEither parseJSON v</code></pre>
<p>This function is exactly what we need for our <code>MimeUnrender</code> instance.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">MimeUnrender</span> <span class="dt">JSON</span> a <span class="kw">where</span>
    mimeUnrender _ <span class="fu">=</span> eitherDecodeLenient</code></pre>
<p>And this is all the code that lets you use <code>JSON</code> for with <code>ReqBody</code>, <code>Get</code>, <code>Post</code> and friends. We can check our understanding by implementing support for an <code>HTML</code> content type, so that users of your webservice can access an HTML representation of the data they want, ready to be included in any HTML document, e.g using <a href="https://api.jquery.com/load/">jQuery’s <code>load</code> function</a>, simply by adding <code>Accept: text/html</code> to their request headers.</p>
</section>
<section id="case-studies-servant-blaze-and-servant-lucid" class="level3">
<h3>Case-studies: <em>servant-blaze</em> and <em>servant-lucid</em></h3>
<p>These days, most of the haskellers who write their HTML UIs directly from Haskell use either <a href="http://hackage.haskell.org/package/blaze-html">blaze-html</a> or <a href="http://hackage.haskell.org/package/lucid">lucid</a>. The best option for <em>servant</em> is obviously to support both (and hopefully other templating solutions!).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HTML</span></code></pre>
<p>Once again, the data type is just there as a symbol for the encoding/decoding functions, except that this time we will only worry about encoding since <em>blaze-html</em> and <em>lucid</em> don’t provide a way to extract data from HTML.</p>
<p>Both packages also have the same <code>Accept</code> instance for their <code>HTML</code> type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Accept</span> <span class="dt">HTML</span> <span class="kw">where</span>
    contentType _ <span class="fu">=</span> <span class="st">&quot;text&quot;</span> <span class="fu">//</span> <span class="st">&quot;html&quot;</span> <span class="fu">/:</span> (<span class="st">&quot;charset&quot;</span>, <span class="st">&quot;utf-8&quot;</span>)</code></pre>
<p>Note that this instance uses the <code>(/:)</code> operator from <em>http-media</em> which lets us specify additional information about a content-type, like the charset here.</p>
<p>The rendering instances for both packages both call similar functions that take types with an appropriate instance to an “abstract” HTML representation and then write that to a <code>ByteString</code>.</p>
<p>For <em>lucid</em>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToHtml</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">HTML</span> a <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderBS <span class="fu">.</span> toHtml

<span class="co">-- let's also provide an instance for lucid's</span>
<span class="co">-- 'Html' wrapper.</span>
<span class="kw">instance</span> <span class="dt">MimeRender</span> <span class="dt">HTML</span> (<span class="dt">Html</span> a) <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderBS</code></pre>
<p>For <em>blaze-html</em>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToMarkup</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">HTML</span> a <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderHtml <span class="fu">.</span> toHtml

<span class="co">-- while we're at it, just like for lucid we can</span>
<span class="co">-- provide an instance for rendering blaze's 'Html' type</span>
<span class="kw">instance</span> <span class="dt">MimeRender</span> <span class="dt">HTML</span> <span class="dt">Html</span> <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderHtml</code></pre>
<p>Both <a href="http://hackage.haskell.org/package/servant-blaze">servant-blaze</a> and <a href="http://hackage.haskell.org/package/servant-lucid">servant-lucid</a> let you use <code>HTML</code> in any content type list as long as you provide an instance of the appropriate class (<code>ToMarkup</code> for <em>blaze-html</em>, <code>ToHtml</code> for <em>lucid</em>).</p>
<p>We can now write webservice that uses <em>servant-lucid</em> to show the <code>HTML</code> content type in action. First off, imports and pragmas as usual.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (foldMap)
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Lucid</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant</span>
<span class="kw">import </span><span class="dt">Servant.HTML.Lucid</span></code></pre>
<p>We will be serving the following API:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PersonAPI</span> <span class="fu">=</span> <span class="st">&quot;persons&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON, HTML] [Person]</span></code></pre>
<p>where <code>Person</code> is defined as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span>
  {<span class="ot"> firstName ::</span> <span class="dt">String</span>
  ,<span class="ot"> lastName  ::</span> <span class="dt">String</span>
  ,<span class="ot"> age       ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span> <span class="co">-- for the JSON instance</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span></code></pre>
<p>Now, let’s teach <em>lucid</em> how to render a <code>Person</code> as a row in a table, and then a list of <code>Person</code>s as a table with a row per person.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- HTML serialization of a single person</span>
<span class="kw">instance</span> <span class="dt">ToHtml</span> <span class="dt">Person</span> <span class="kw">where</span>
  toHtml p <span class="fu">=</span>
    tr_ <span class="fu">$</span> <span class="kw">do</span>
      td_ (toHtml <span class="fu">$</span> firstName p)
      td_ (toHtml <span class="fu">$</span> lastName p)
      td_ (toHtml <span class="fu">.</span> show <span class="fu">$</span> age p)

  <span class="co">-- do not worry too much about this</span>
  toHtmlRaw <span class="fu">=</span> toHtml

<span class="co">-- HTML serialization of a list of persons</span>
<span class="kw">instance</span> <span class="dt">ToHtml</span> [<span class="dt">Person</span>] <span class="kw">where</span>
  toHtml persons <span class="fu">=</span> table_ <span class="fu">$</span> <span class="kw">do</span>
    tr_ <span class="fu">$</span> <span class="kw">do</span>
      td_ <span class="st">&quot;first name&quot;</span>
      td_ <span class="st">&quot;last name&quot;</span>
      td_ <span class="st">&quot;age&quot;</span>

    <span class="co">-- this just calls toHtml on each person of the list</span>
    <span class="co">-- and concatenates the resulting pieces of HTML together</span>
    foldMap toHtml persons

  toHtmlRaw <span class="fu">=</span> toHtml</code></pre>
<p>We create some <code>Person</code> values and serve them as a list:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">persons ::</span> [<span class="dt">Person</span>]
persons <span class="fu">=</span>
  [ <span class="dt">Person</span> <span class="st">&quot;Isaac&quot;</span>  <span class="st">&quot;Newton&quot;</span>   <span class="dv">372</span>
  , <span class="dt">Person</span> <span class="st">&quot;Albert&quot;</span> <span class="st">&quot;Einstein&quot;</span> <span class="dv">136</span>
  ]

<span class="ot">personAPI ::</span> <span class="dt">Proxy</span> <span class="dt">PersonAPI</span>
personAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">PersonAPI</span>
server <span class="fu">=</span> return persons

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve personAPI server</code></pre>
<p>And we’re good to go. You can run this example with <code>dist/build/tutorial/tutorial 4</code>.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/persons
[<span class="dt">{&quot;lastName&quot;:&quot;Newton&quot;,&quot;age&quot;:372,&quot;firstName&quot;:&quot;Isaac&quot;},{&quot;lastName&quot;:&quot;Einstein&quot;,&quot;age&quot;:136,&quot;firstName&quot;:&quot;Albert&quot;}</span>]
$ <span class="kw">curl</span> -H <span class="st">'Accept: text/html'</span> http://localhost:8081/persons
<span class="kw">&lt;table&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>first name<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>last name<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>age<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Isaac<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Newton<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;372&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Albert<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Einstein<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;136&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>/table<span class="kw">&gt;</span>
<span class="co"># or just point your browser to http://localhost:8081/persons</span></code></pre>
</section>
</section>
<section id="the-eithert-servanterr-io-monad" class="level2">
<h2>The <code>EitherT ServantErr IO</code> monad</h2>
<p>At the heart of the handlers is the monad they run in, namely <code>EitherT ServantErr IO</code>. One might wonder: why this monad? The answer is that it is the simplest monad with the following properties:</p>
<ul>
<li>it lets us both return a successful result (with the <code>Right</code> branch of <code>Either</code>) or “fail” with a descriptive error (with the <code>Left</code> branch of <code>Either</code>);</li>
<li>it lets us perform IO, which is absolutely vital since most webservices exist as interfaces to databases that we interact with in <code>IO</code>;</li>
</ul>
<p>Let’s recall some definitions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from the Prelude</span>
<span class="kw">data</span> <span class="dt">Either</span> e a <span class="fu">=</span> <span class="dt">Left</span> e <span class="fu">|</span> <span class="dt">Right</span> a

<span class="co">-- from the 'either' package at</span>
<span class="co">-- http://hackage.haskell.org/package/either-4.3.3.2/docs/Control-Monad-Trans-Either.html</span>
<span class="kw">newtype</span> <span class="dt">EitherT</span> e m a
  <span class="fu">=</span> <span class="dt">EitherT</span> {<span class="ot"> runEitherT ::</span> m (<span class="dt">Either</span> e a) }</code></pre>
<p>In short, this means that a handler of type <code>EitherT ServantErr IO a</code> is simply equivalent to a computation of type <code>IO (Either ServantErr a)</code>, that is, an IO action that either returns an error or a result.</p>
<p>The aforementioned <code>either</code> package is worth taking a look at. Perhaps most importantly:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">left ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">EitherT</span> e m a</code></pre>
<p>Allows you to return an error from your handler (whereas <code>return</code> is enough to return a success).</p>
<p>Most of what you’ll be doing in your handlers is running some IO and, depending on the result, you might sometimes want to throw an error of some kind and abort early. The next two sections cover how to do just that.</p>
<section id="performing-io" class="level3">
<h3>Performing IO</h3>
<p>Another important instance from the list above is <code>MonadIO m =&gt; MonadIO (EitherT e m)</code>. <a href="http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-IO-Class.html"><code>MonadIO</code></a> is a class from the <em>transformers</em> package defined as:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span>
<span class="ot">  liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre>
<p>Obviously, the <code>IO</code> monad provides a <code>MonadIO</code> instance. Hence for any type <code>e</code>, <code>EitherT e IO</code> has a <code>MonadIO</code> instance. So if you want to run any kind of IO computation in your handlers, just use <code>liftIO</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IOAPI</span> <span class="fu">=</span> <span class="st">&quot;myfile.txt&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] FileContent</span>

<span class="kw">newtype</span> <span class="dt">FileContent</span> <span class="fu">=</span> <span class="dt">FileContent</span>
  {<span class="ot"> content ::</span> <span class="dt">String</span> }
  <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">FileContent</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">IOAPI</span>
server <span class="fu">=</span> <span class="kw">do</span>
  filecontent <span class="ot">&lt;-</span> liftIO (readFile <span class="st">&quot;myfile.txt&quot;</span>)
  return (<span class="dt">FileContent</span> filecontent)</code></pre>
</section>
<section id="failing-through-servanterr" class="level3">
<h3>Failing, through <code>ServantErr</code></h3>
<p>If you want to explicitly fail at providing the result promised by an endpoint using the appropriate HTTP status code (not found, unauthorized, etc) and some error message, all you have to do is use the <code>left</code> function mentioned above and provide it with the appropriate value of type <code>ServantErr</code>, which is defined as:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ServantErr</span> <span class="fu">=</span> <span class="dt">ServantErr</span>
    {<span class="ot"> errHTTPCode     ::</span> <span class="dt">Int</span>
    ,<span class="ot"> errReasonPhrase ::</span> <span class="dt">String</span>
    ,<span class="ot"> errBody         ::</span> <span class="dt">ByteString</span> <span class="co">-- lazy bytestring</span>
    ,<span class="ot"> errHeaders      ::</span> [<span class="dt">Header</span>]
    }</code></pre>
<p>Many standard values are provided out of the box by the <code>Servant.Server</code> module. If you want to use these values but add a body or some headers, just use record update syntax:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">failingHandler <span class="fu">=</span> left myerr

  <span class="kw">where</span><span class="ot"> myerr ::</span> <span class="dt">ServantErr</span>
        myerr <span class="fu">=</span> err503 { errBody <span class="fu">=</span> <span class="st">&quot;Sorry dear user.&quot;</span> }</code></pre>
<p>Here’s an example where we return a customised 404-Not-Found error message in the response body if “myfile.txt” isn’t there:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IOAPI</span> <span class="fu">=</span> <span class="st">&quot;myfile.txt&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] FileContent</span>

<span class="kw">newtype</span> <span class="dt">FileContent</span> <span class="fu">=</span> <span class="dt">FileContent</span>
  {<span class="ot"> content ::</span> <span class="dt">String</span> }
  <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">FileContent</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">IOAPI</span>
server <span class="fu">=</span> <span class="kw">do</span>
  exists <span class="ot">&lt;-</span> liftIO (doesFileExist <span class="st">&quot;myfile.txt&quot;</span>)
  <span class="kw">if</span> exists
    <span class="kw">then</span> liftIO (readFile <span class="st">&quot;myfile.txt&quot;</span>) <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> <span class="dt">FileContent</span>
    <span class="kw">else</span> left custom404Err

  <span class="kw">where</span> custom404Err <span class="fu">=</span> err404 { errBody <span class="fu">=</span> <span class="st">&quot;myfile.txt just isn't there, please leave this server alone.&quot;</span> }</code></pre>
<p>Let’s run this server (<code>dist/build/tutorial/tutorial 5</code>) and query it, first without the file and then with the file.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> --verbose http://localhost:8081/myfile.txt
[<span class="kw">snip</span>]
<span class="kw">*</span> Connected to localhost (127.0.0.1) <span class="kw">port</span> 8081 (#0)
<span class="kw">&gt;</span> <span class="kw">GET</span> /myfile.txt HTTP/1.1
<span class="kw">&gt;</span> <span class="kw">User-Agent</span>: curl/7.30.0
<span class="kw">&gt;</span> <span class="kw">Host</span>: localhost:8081
<span class="kw">&gt;</span> <span class="kw">Accept</span>: */*
<span class="kw">&gt;</span>
<span class="kw">&lt;</span> <span class="kw">HTTP/1.1</span> 404 Not Found
[<span class="kw">snip</span>]
<span class="kw">myfile.txt</span> just isnt there, please leave this server alone.

$ <span class="kw">echo</span> Hello <span class="kw">&gt;</span> myfile.txt

$ <span class="kw">curl</span> --verbose http://localhost:8081/myfile.txt
[<span class="kw">snip</span>]
<span class="kw">*</span> Connected to localhost (127.0.0.1) <span class="kw">port</span> 8081 (#0)
<span class="kw">&gt;</span> <span class="kw">GET</span> /myfile.txt HTTP/1.1
<span class="kw">&gt;</span> <span class="kw">User-Agent</span>: curl/7.30.0
<span class="kw">&gt;</span> <span class="kw">Host</span>: localhost:8081
<span class="kw">&gt;</span> <span class="kw">Accept</span>: */*
<span class="kw">&gt;</span>
<span class="kw">&lt;</span> <span class="kw">HTTP/1.1</span> 200 OK
[<span class="kw">snip</span>]
<span class="kw">&lt;</span> <span class="kw">Content-Type</span>: application/json
[<span class="kw">snip</span>]
<span class="dt">{&quot;content&quot;:&quot;Hello\n&quot;}</span></code></pre>
</section>
</section>
<section id="serving-static-files" class="level2">
<h2>Serving static files</h2>
<p><em>servant-server</em> also provides a way to just serve the content of a directory under some path in your web API. As mentioned earlier in this document, the <code>Raw</code> combinator can be used in your APIs to mean “plug here any WAI application”. Well, servant-server provides a function to get a file and directory serving WAI application, namely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- exported by Servant and Servant.Server</span>
<span class="ot">serveDirectory ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">Raw</span></code></pre>
<p><code>serveDirectory</code>’s argument must be a path to a valid directory. You can see a example below, runnable with <code>dist/build/tutorial/tutorial 6</code> (you <strong>must</strong> run it from within the <em>servant-examples/</em> directory!), which is a webserver that serves the various bits of code covered in this getting-started.</p>
<p>The API type will be the following.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;code&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Raw</span></code></pre>
<p>And the server:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span>
api <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span>
server <span class="fu">=</span> serveDirectory <span class="st">&quot;tutorial&quot;</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve api server</code></pre>
<p>This server will match any request whose path starts with <code>/code</code> and will look for a file at the path described by the rest of the request path, inside the <em>tutorial/</em> directory of the path you run the program from.</p>
<p>In other words:</p>
<ul>
<li>If a client requests <code>/code/foo.txt</code>, the server will look for a file at <code>./tutorial/foo.txt</code> (and fail)</li>
<li>If a client requests <code>/code/T1.hs</code>, the server will look for a file at <code>./tutorial/T1.hs</code> (and succeed)</li>
<li>If a client requests <code>/code/foo/bar/baz/movie.mp4</code>, the server will look for a file at <code>./tutorial/foo/bar/baz/movie.mp4</code> (and fail)</li>
</ul>
<p>Here is our little server in action.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>code<span class="fu">/</span>T1.hs
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="kw">module</span> <span class="dt">T1</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Time.Calendar</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant</span>

<span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
  {<span class="ot"> name ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> email ::</span> <span class="dt">String</span>
  ,<span class="ot"> registration_date ::</span> <span class="dt">Day</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="co">-- orphan ToJSON instance for Day. necessary to derive one for User</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Day</span> <span class="kw">where</span>
  <span class="co">-- display a day in YYYY-mm-dd format</span>
  toJSON d <span class="fu">=</span> toJSON (showGregorian d)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span>

<span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span>

<span class="ot">users ::</span> [<span class="dt">User</span>]
users <span class="fu">=</span>
  [ <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span>    <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span>  <span class="dv">3</span> <span class="dv">1</span>)
  , <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span>         (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)
  ]

<span class="ot">userAPI ::</span> <span class="dt">Proxy</span> <span class="dt">UserAPI</span>
userAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">UserAPI</span>
server <span class="fu">=</span> return users

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve userAPI server
<span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>code<span class="fu">/</span>tutorial<span class="fu">.</span>hs
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span>
<span class="kw">import </span><span class="dt">System.Environment</span>

<span class="kw">import qualified</span> <span class="dt">T1</span>
<span class="kw">import qualified</span> <span class="dt">T2</span>
<span class="kw">import qualified</span> <span class="dt">T3</span>
<span class="kw">import qualified</span> <span class="dt">T4</span>
<span class="kw">import qualified</span> <span class="dt">T5</span>
<span class="kw">import qualified</span> <span class="dt">T6</span>
<span class="kw">import qualified</span> <span class="dt">T7</span>
<span class="kw">import qualified</span> <span class="dt">T9</span>
<span class="kw">import qualified</span> <span class="dt">T10</span>

<span class="ot">app ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
app n f <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span>
  <span class="st">&quot;1&quot;</span> <span class="ot">-&gt;</span> f T1.app
  <span class="st">&quot;2&quot;</span> <span class="ot">-&gt;</span> f T2.app
  <span class="st">&quot;3&quot;</span> <span class="ot">-&gt;</span> f T3.app
  <span class="st">&quot;4&quot;</span> <span class="ot">-&gt;</span> f T4.app
  <span class="st">&quot;5&quot;</span> <span class="ot">-&gt;</span> f T5.app
  <span class="st">&quot;6&quot;</span> <span class="ot">-&gt;</span> f T6.app
  <span class="st">&quot;7&quot;</span> <span class="ot">-&gt;</span> f T7.app
  <span class="st">&quot;8&quot;</span> <span class="ot">-&gt;</span> f T3.app
  <span class="st">&quot;9&quot;</span> <span class="ot">-&gt;</span> T9.writeJSFiles <span class="fu">&gt;&gt;</span> f T9.app
  <span class="st">&quot;10&quot;</span> <span class="ot">-&gt;</span> f T10.app
  _   <span class="ot">-&gt;</span> usage

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs
  <span class="kw">case</span> args <span class="kw">of</span>
    [n] <span class="ot">-&gt;</span> app n (run <span class="dv">8081</span>)
    _   <span class="ot">-&gt;</span> usage

<span class="ot">usage ::</span> <span class="dt">IO</span> ()
usage <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Usage:\t tutorial N&quot;</span>
  putStrLn <span class="st">&quot;\t\twhere N is the number of the example you want to run.&quot;</span>

<span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>foo
not found</code></pre>
</section>
<section id="using-another-monad-for-your-handlers" class="level2">
<h2>Using another monad for your handlers</h2>
<p>Remember how <code>Server</code> turns combinators for HTTP methods into <code>EitherT ServantErr IO</code>? Well, actually, there’s more to that. <code>Server</code> is actually a simple type synonym.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Server</span> api <span class="fu">=</span> <span class="dt">ServerT</span> api (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)</code></pre>
<p><code>ServerT</code> is the actual type family that computes the required types for the handlers that’s part of the <code>HasServer</code> class. It’s like <code>Server</code> except that it takes a third parameter which is the monad you want your handlers to run in, or more generally the return types of your handlers. This third parameter is used for specifying the return type of the handler for an endpoint, e.g when computing <code>ServerT (Get '[JSON] Person) SomeMonad</code>. The result would be <code>SomeMonad Person</code>.</p>
<p>The first and main question one might have then is: how do we write handlers that run in another monad? How can we “bring back” the value from a given monad into something <em>servant</em> can understand?</p>
<section id="natural-transformations" class="level3">
<h3>Natural transformations</h3>
<p>If we have a function that gets us from an <code>m a</code> to an <code>n a</code>, for any <code>a</code>, what do we have?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> m <span class="fu">:~&gt;</span> n <span class="fu">=</span> <span class="dt">Nat</span> {<span class="ot"> unNat ::</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a}

<span class="co">-- For example</span>
<span class="co">-- listToMaybeNat ::`[] :~&gt; Maybe`</span>
<span class="co">-- listToMaybeNat = Nat listToMaybe  -- from Data.Maybe</span></code></pre>
<p>(<code>Nat</code> comes from “natural transformation”, in case you’re wondering.)</p>
<p>So if you want to write handlers using another monad/type than <code>EitherT ServantErr IO</code>, say the <code>Reader String</code> monad, the first thing you have to prepare is a function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readerToEither ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="fu">:~&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span></code></pre>
<p>Let’s start with <code>readerToEither'</code>. We obviously have to run the <code>Reader</code> computation by supplying it with a <code>String</code>, like <code>&quot;hi&quot;</code>. We get an <code>a</code> out from that and can then just <code>return</code> it into <code>EitherT</code>. We can then just wrap that function with the <code>Nat</code> constructor to make it have the fancier type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readerToEither' ::</span> forall a<span class="fu">.</span> <span class="dt">Reader</span> <span class="dt">String</span> a <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> a
readerToEither' r <span class="fu">=</span> return (runReader r <span class="st">&quot;hi&quot;</span>)

<span class="ot">readerToEither ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="fu">:~&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>
readerToEither <span class="fu">=</span> <span class="dt">Nat</span> <span class="fu">.</span> readerToEither'</code></pre>
<p>We can write some simple webservice with the handlers running in <code>Reader String</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ReaderAPI</span> <span class="fu">=</span> <span class="st">&quot;a&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Int</span>
            <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;b&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] String</span>

<span class="ot">readerAPI ::</span> <span class="dt">Proxy</span> <span class="dt">ReaderAPI</span>
readerAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">readerServerT ::</span> <span class="dt">ServerT</span> <span class="dt">ReaderAPI</span> (<span class="dt">Reader</span> <span class="dt">String</span>)
readerServerT <span class="fu">=</span> a <span class="fu">:&lt;|&gt;</span> b

  <span class="kw">where</span><span class="ot"> a ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="dt">Int</span>
        a <span class="fu">=</span> return <span class="dv">1797</span>

<span class="ot">        b ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="dt">String</span>
        b <span class="fu">=</span> ask</code></pre>
<p>we unfortunately can’t use <code>readerServerT</code> as an argument of <code>serve</code>, because <code>serve</code> wants a <code>Server ReaderAPI</code>, i.e with handlers running in <code>EitherT ServantErr IO</code>. But there’s a simple solution to this.</p>
</section>
<section id="enter-enter" class="level3">
<h3>Enter <code>enter</code></h3>
<p>That’s right. We have just written <code>readerToEither</code>, which is exactly what we could need to call on the results of all handlers to make the handlers have the right type for <code>serve</code>. Being cumbersome to do by hand, we provide a function <code>enter</code> which takes a natural transformation between two parametrized types <code>m</code> and <code>n</code> and a <code>ServerT someapi m</code>, and returns a <code>ServerT someapi n</code>.</p>
<p>In our case, we can wrap up our little webservice by using <code>enter readerToEither</code> on our handlers.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readerServer ::</span> <span class="dt">Server</span> <span class="dt">ReaderAPI</span>
readerServer <span class="fu">=</span> enter readerToEither readerServerT

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve readerAPI readerServer</code></pre>
<p>And we can indeed see this webservice in action by running <code>dist/build/tutorial/tutorial 7</code>.</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/a
<span class="kw">1797</span>
$ <span class="kw">curl</span> http://localhost:8081/b
<span class="st">&quot;hi&quot;</span></code></pre>
</section>
</section>
<section id="conclusion" class="level2">
<h2>Conclusion</h2>
<p>You’re now equipped to write any kind of webservice/web-application using <em>servant</em>. One thing not covered here is how to incorporate your own combinators and will be the topic of a page on the website. The rest of this document focuses on <em>servant-client</em>, <em>servant-jquery</em> and <em>servant-docs</em>.</p>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
