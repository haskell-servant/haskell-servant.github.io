<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Content Type Bliss - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">servant</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../blog.html">Blog</a>
                <a href="../tutorial">Tutorial</a>
                <a href="../tips.html">Tips and tricks</a>
                <a href="../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Content Type Bliss</h1>

            <p>Recently I came across Timo von Holtz’s <a href="https://hackage.haskell.org/package/servant-JuicyPixels">servant-JuicyPixels</a> package. It describes <code>servant</code>-compatible content-types for JuicyPixel’s <code>DynamicImage</code> data type, and clocks under 100 airy lines.</p>
<p>Timo and I realized there is a pretty neat demonstration of the advantage of abstracting away content-type serialization and deserialization: the world’s most concise image-conversion web service. Essentially the same application is available as the <a href="https://github.com/tvh/servant-JuicyPixels/blob/master/examples/image-conversion.hs"><code>image conversion</code> example</a> in Timo’s package.</p>
<p>(If you want to know more about how content-types work in <code>servant</code>, the <a href="http://haskell-servant.github.io/tutorial/server.html#using-content-types-with-your-data-types">content-type section of the tutorial</a> has more information.)</p>
<section id="the-application" class="level1">
<h1>The Application</h1>
<p>Our goal is to provide a service that converts images between formats based on the <code>Content-Type</code> and <code>Accept</code> headers of the request:</p>
<pre class="shell"><code>$ curl localhost:8001 -H &quot;Content-Type: image/png&quot;  \
                      -H &quot;Accept: image/jpeg&quot;  \
                      --data-binary &quot;@haskell-logo.png&quot; \
                      &gt; haskell-logo.jpeg</code></pre>
<p>To get there, we need to do a couple of things. We need to of course run the application:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">main <span class="fu">=</span> run <span class="dv">8001</span> conversion</a></code></pre></div>
<p>And describe the API:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ConversionApi</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">     <span class="fu">=</span> <span class="dt">ReqBody</span> '[<span class="dt">BMP</span>, <span class="dt">GIF</span>, <span class="dt">JPEG</span> <span class="dv">50</span>, <span class="dt">PNG</span>, <span class="dt">TIFF</span>, <span class="dt">RADIANCE</span>] <span class="dt">DynamicImage</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="fu">:&gt;</span> <span class="dt">Post</span> '[<span class="dt">BMP</span>, <span class="dt">GIF</span>, <span class="dt">JPEG</span> <span class="dv">50</span>, <span class="dt">PNG</span>, <span class="dt">TIFF</span>, <span class="dt">RADIANCE</span>] <span class="dt">DynamicImage</span></a></code></pre></div>
<p>As you can see, we state that we accept and can return a variety of image formats.</p>
<p>The application is then:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">conversion ::</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">conversion <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">ConversionApi</span>) handler</a></code></pre></div>
<p>And for the clincher, the handler:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">    <span class="kw">where</span> handler <span class="fu">=</span> return</a></code></pre></div>
<p>And that’s it!</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>This is just the limit of the relative gain of abstracting content-types - there is nothing to the application besides them!</p>
<p>Essentially the same idea could of course be applied to other areas. Document conversion with Pandoc, video and audio formats, etc.</p>
</section>

<div class="info">
    Posted on August  5, 2015
    
        by Julian K. Arni
    
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
