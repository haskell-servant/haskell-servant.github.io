---
title: servant 0.3 released
author: Alp Mestanogullari
date: 2050-05-01 13:00
description: This new version of servant is cool.
tags: release, 0.3, content-types, response-headers, website
---

Since [the last major release](http://alpmestan.com/posts/2014-12-09-rethinking-webservices-apis-haskell.html),
a lot happened in and around *servant*. Definitely enough to justify a new one.
This post announces new releases of all the servant packages, with many local
changes but also some major ones that affect all packages. You can find the
detailed changelogs at the end of this post, but here are a few major features
you may want to learn about.

# Multiple content-type support

*servant* combinators are not JSON-centric anymore.

If you had an API type like the following with servant *0.2.x*:

``` haskell
type API = -- list users
           "users" :> Get [User]
           -- update an user
      :<|> "user" :> Capture "username" Text :> ReqBody User :> Put ()
```

You now have to change it to:

``` haskell
type API = -- list users
           "users" :> Get '[JSON] [User]
      :<|> "user" :> Capture "username" Text :> ReqBody '[JSON] User :> Put '[JSON] ()
```

Wherever applicable (i.e `ReqBody` and all the combinators that correspond to
an HTTP method), you can now specify all the content types in which you
want to want to be able to encode/decode values. As you can see, we use the
`DataKinds` GHC extension to let you specify a type-level list of
content-types, which are simple dummy types:

``` haskell
data JSON
```

In *servant-server*, a list of these content-types as the first argument of a
method gets translated into a set of constraints on the return type:

``` haskell
Get '[JSON, PlainText] Int
==>
MimeRender JSON Int, MimeRender PlainText Int => EitherT ServantErr IO Int
```

Which have unsurprising instances:

``` haskell
instance (ToJSON a) => MimeRender JSON a
```

Thus, *servant* checks at _compile-time_ that it really can serialize your
values as you describe. And of course, it handles picking the appropriate
serialization format based on the request's "Accept" header for you.

(For `ReqBody`, _deserialization_ is involved. For *servant-client*, the logic
 goes the other way around - serialization for `ReqBody`, deserialization for
 methods.)

# Servant-blaze and servant-lucid

Declaring new content-types, and the associated constraints for them, is quite
easy. But to make it easier still, we are also announcing two new packages:
servant-blaze and servant-lucid. To use them, just import their `HTML`
datatype:

``` haskell
import Servant.HTML.Lucid (HTML) -- or Servant.HTML.Blaze

type MyHTML = Get '[HTML] User
```

And `User` will be checked for the appropriate (e.g. `ToHtml`) instance.

# Response headers

There was no easy way so far to have handlers add headers to a response. We've
since come up with a solution that stays true to the *servant* spirit: _what_
headers your response will include (and what their types are) is still enforced
statically:

``` haskell
type MyHandler = Get '[JSON] (Headers '[Header "Location" Link] User)

myHandler :: Server MyHandler
myHandler = return $ addHeader <someLink> $ <someuser>
```

*servant-docs* and *servant-client* are also response-header aware.

# Monads etc.

An often-requested feature has been easy use of datatypes besides `EitherT`. Now
we believe we have a good story for that (thanks in large part to rschatz). To
convert from one datatype to another, all you need to do is provide a natural
transformation between them. For example:

``` haskell
type ReaderAPI = "a" :> Get '[JSON] Int
            :<|> "b" :> Get '[JSON] String

readerServerT :: ServerT ReaderAPI (Reader String)
readerServerT = return 1797 :<|> ask

readerServer :: Server ReaderAPI
readerServer = enter (Nat $ return . (`runReader` "hi")) readerServerT
```
The new `ServerT` type synonym takes an extra paramer that represents what
datatype you are using over your handlers (instead of `EitherT ServantErr IO`).

(Note that we also provide a number of pre-existing `Nat`s, which are an
 instance of `Category`. We could have used

```
readerServer = enter (generalizeNat . (runReaderTNat "hi")) readerServerT
```
instead (with `.` being from `Control.Category`).)

Note that the datatypes you can use now don't even need to be monads!

# mkLink

Somewhere between the 0.2 release and now, `mkLink` got a whole lot better
(thanks Christian Marie!). `mkLink` makes urls that are statically guaranteed
to belong to your API, without any Template Haskell. Combined with response
headers, you can now easily create, for instance, type-safe redirect headers.
Combined with the new HTML support, you can easily make links that you know
will not 404.

# Left

We also changed the default type of handlers from `EitherT (Int,String) IO a` to
`EitherT ServantErr IO a`. Now it is possible to return headers and a response
body in the `Left` case.

We also now export function `errXXX` (where `XXX` is a 300-599 HTTP status code)
with sensible reason strings.

# Conclusions

As you can see, more and more information is getting encoded statically - the
types are becoming a pretty rich DSL. In order to keep the noise down, do what
you normally do: abstract away common patterns! If your endpoints always return
the same content-types, make aliases:

``` haskell
type Get' a = Get '[JSON, HTML, PlainText] a
```

There's still an outstanding issue with the errors servant returns when a
request doesn't get handled. For example, if the path of a request, but not the
method nor the request obdy, match, rather than returning a 405 (Method Not
Allowed) we return a 400 (Bad Request), which is not the desired behavior.
Andres LÃ¶h made some great suggestions for how to improve our routing time
complexity, and hopefully we can integrate a fix for this issue when we tackle
that.

We also merged our repos into [servant](https://github.com/haskell-servant/servant).
Please use that repo exclusively for PRs and issues (we'll get rid of the
others eventually).
