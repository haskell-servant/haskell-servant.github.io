<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Passing a DB connection to handlers in Servant - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../css/foundation.min.css" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div class="top-bar-container">
            <div class="grid-container">
                <div class="grid-x">
                    <div class="medium-2 text-center"><a href="../">Servant</a></div>
                    <div class="medium-2 text-center"><a href="../blog.html">Blog</a></div>
                    <div class="medium-2 text-center"><a href="https://haskell-servant.readthedocs.io/en/latest/tutorial/index.html">Tutorial↦</a></div>
                    <div class="medium-2 text-center"><a href="https://haskell-servant.readthedocs.io/en/latest/cookbook/index.html">Cookbook↦</a></div>
                    <div class="medium-2 text-center"><a href="../talks.html">Talks</a></div>
                    <div class="medium-2 text-center"><a href="https://github.com/haskell-servant/servant">GitHub↦</a></div>
                </div>
            </div>
        </div>

        <div id="content" class="grid-container"><div class="grid-x">
            <div class="cell"><h1>Passing a DB connection to handlers in Servant</h1></div>

            <div class="cell"><p>This post is originally published in http://oleg.fi/gists/posts/2017-03-03-servant-and-db.html. This version is updated to use <code>hoistServer</code>.</p>
<p>This write-up is motivated by discussion in <a href="https://github.com/haskell-servant/servant/issues/704">servant/#704 issue</a>. I try to summarize the main points.</p>
<p>As this is a literate haskell file, we’ll need to do a small prelude dance:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Pool</span> (<span class="dt">Pool</span>, withResource)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Control.Monad.Base</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Control</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Database.PostgreSQL.Simple</span> (<span class="dt">Connection</span>)</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Log</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Servant</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Category</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="co">-- | Needed for 'MonadLog (LogT Handler)' instance</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">MonadTime</span> <span class="dt">Handler</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    currentTime <span class="fu">=</span> liftIO currentTime</a></code></pre></div>
<section id="the-problem" class="level2">
<h2>The problem</h2>
<p>The issue started as instance XY-problem:</p>
<ul>
<li><strong>Y</strong>: Docs explaining how to actually create a full combinator (ex. one to create/store a DB connection)</li>
<li><strong>X</strong>: How to pass a db connection to the handlers.</li>
</ul>
<p>I won’t answer to the <strong>Y</strong>, how to write combinators is different topic (have to write about that later). Let’s see how to deal with <strong>X</strong>, by implementing a small Cat CR(UD) API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- we should have proper data/newtypes, but then we'll need to write instances.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- we'll try to keep a boilerplate at the minimum in this example.</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Cat</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">type</span> <span class="dt">CatName</span> <span class="fu">=</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;cat&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;name&quot;</span> <span class="dt">CatName</span> <span class="fu">:&gt;</span> <span class="dt">Put</span> '[<span class="dt">JSON</span>] <span class="dt">Cat</span>  <span class="co">-- create</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cat&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;name&quot;</span> <span class="dt">CatName</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> '[<span class="dt">JSON</span>] <span class="dt">Cat</span>  <span class="co">-- read</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">api <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>Now we’ll need to implement the api, we’ll write a basic Haskell functions, which we would write anyway, we could reuse them in a console application, for example.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">createCat ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">createCat <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">readCat ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">readCat <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a></code></pre></div>
<p>And the problem is that if we try to do</p>
<pre class="foo"><code>-- THIS DOESN'T WORK
app :: Application
app = serve api $ createCat :&lt;|&gt; readCat</code></pre>
<p>it will fail with a type-error message from GHC. Obviously, GHC cannot conjure <code>Connection</code> for us. We need to pass it in somehow.</p>
</section>
<section id="partial-application" class="level2">
<h2>Partial application</h2>
<p><em>Partial application</em> is a simple tool. We can partially apply the implementation to fit into type required by <code>serve</code>. We’ll make a situation a bit more interesting by using a connection pool:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">app ::</span> <span class="dt">Pool</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">app pool <span class="fu">=</span> serve api <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    withResource1 pool createCat <span class="fu">:&lt;|&gt;</span> withResource1 pool readCat</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">    withResource1 ::</span> <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m <span class="ot">=&gt;</span> <span class="dt">Pool</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m c</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    withResource1 pool f b <span class="fu">=</span> withResource pool <span class="fu">$</span> \a <span class="ot">-&gt;</span> f a b</a></code></pre></div>
<p>As you can see we’d need to wrap every handler in <code>withResource1</code>. It’s not very elegant, but <strong>it works</strong>. And is very <strong>simple</strong> to understand.</p>
</section>
<section id="hoistserver" class="level2">
<h2>hoistServer</h2>
<p><code>servant</code> offers the <a href="http://hackage.haskell.org/package/servant-server-0.14/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> helper function. which let’s you to remove this kind of boilerplate. We’ll rewrite our handlers in MTL-style, with a <code>MonadDB</code> type class. For the sake of example let’s also add a <code>MonadLog</code> from <a href="http://hackage.haskell.org/package/log-base"><code>log-base</code></a> to the first endpoint.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">MonadDB</span> m <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    withConnection ::</span> (<span class="dt">Connection</span> <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">createCat' ::</span> (<span class="dt">MonadDB</span> m, <span class="dt">MonadLog</span> m) <span class="ot">=&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">createCat' <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">readCat' ::</span> (<span class="dt">MonadDB</span> m) <span class="ot">=&gt;</span> <span class="dt">CatName</span> <span class="ot">-&gt;</span> m <span class="dt">Cat</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">readCat' <span class="fu">=</span> error <span class="st">&quot;not implemented&quot;</span></a></code></pre></div>
<p>Looks good, but how we’ll pass a connection (and a logger)? The answer is obvious, when you know it: we’ll need to use a concrete monad implementation, for example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">H</span> a <span class="fu">=</span> <span class="dt">H</span> {<span class="ot"> runH ::</span> <span class="dt">ReaderT</span> (<span class="dt">Pool</span> <span class="dt">Connection</span>) (<span class="dt">LogT</span> <span class="dt">Handler</span>) a }</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">   <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadTime</span>, <span class="dt">MonadLog</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">MonadDB</span> <span class="dt">H</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    withConnection f <span class="fu">=</span> <span class="dt">H</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        pool <span class="ot">&lt;-</span> ask</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        withResource pool <span class="fu">$</span> \conn <span class="ot">-&gt;</span> runH (f conn)</a></code></pre></div>
<p>And now <code>hoistServer</code> will do the magic:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">app' ::</span> <span class="dt">Pool</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">app' pool logger <span class="fu">=</span> serve api <span class="fu">$</span> hoistServer api nt <span class="fu">$</span> createCat' <span class="fu">:&lt;|&gt;</span> readCat'</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">    nt ::</span> <span class="dt">H</span> x <span class="ot">-&gt;</span> <span class="dt">Handler</span> x</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    nt m <span class="ot">-&gt;</span> runLogT <span class="st">&quot;api&quot;</span> logger (runReaderT (runH m) pool)</a></code></pre></div>
<p>The <code>nt</code> (for natural transformation) tells how to transform the concrete monad <code>H</code> into servant’s <code>Handler</code>. The <code>hoistServer</code> machinery walks through <code>ServerT H</code> value and applies that transformation, resulting into <code>ServerT Handler</code> value. If <code>api</code> has <code>HasServer</code> instance, you can <code>hoistServer</code> it.</p>
<p>The <code>hoistServer</code> is most useful when you have polymorphic handlers defined with mtl-like monad type-classes, so you can instantiate them all with the same concrete monad at then end. Note: that if we had concrete <code>LogT Handler</code> in some handler, and <code>ReaderT (Pool Connection) Handler</code> in some other one, <code>hoistServer</code> won’t help!</p>
<p>So to conclude:</p>
<ul>
<li>start with <em>partial application</em> to pass arguments into handlers</li>
<li>later you may transfer to use fancier <code>hoistServer</code>.</li>
</ul>
<p><a href="https://github.com/haskell-servant/servant/issues/704#issuecomment-283396827">Alp Mestanogullari summarised it well</a>: <em>gradually reach for fancier things as your needs grow, never when it’s not required</em>.</p>
</section>

<div class="post-info">
    Posted on March  3, 2017
    
        by Oleg Grenrus
    
</div>
</div>
        </div></div>
        <div id="footer" class="grid-container"><div class="grid-x"><div class="cell">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div></div<>
    </body>
</html>
